---
title: 使用 GitHub Actions 自动同步仓库详细步骤
description: 这个方法的核心原理是：当你推送到一个主仓库时，GitHub 会自动运行一个预设好的脚本，将你的代码同步到一个或多个目标仓库
publishDate: 2025-09-08T17:18
tags:
  - 技术
ogImage: /social-card.avif
---
**准备工作：明确你的仓库**

●主仓库 (Source Repo)：这是你平时主要推送代码的仓库，也是触发自动同步的仓库。我们称之为 Repo-A。

●目标仓库 (Target Repo)：这是需要被动接收更新的仓库。可以是一个或多个。我们称之为 Repo-B, Repo-C 等。

**第一步：生成专用的 SSH 密钥**

为了安全，我们不使用你个人的 SSH 密钥，而是为这个自动化流程生成一个全新的、专用的密钥。

1. 打开你电脑上的终端（Terminal、Git Bash 或 PowerShell）。
2. 首先，确保 .ssh 文件夹存在。 在终端运行以下命令，如果文件夹不存在，它会帮你创建：

* Windows (在 PowerShell 中运行):

  ```
  if (-not (Test-Path "$env:USERPROFILE\.ssh")) { New-Item -Path "$env:USERPROFILE\.ssh" -ItemType Directory }
  ```
* Mac / Linux:

  ```
  mkdir -p ~/.ssh
  ```

3. 接下来，运行相应的命令来为第一个目标仓库 (Repo-B) 生成密钥文件：

* Windows (在 PowerShell 中运行):

  ```
  ssh-keygen -t rsa -b 4096 -C "github-actions-1" -f "$env:USERPROFILE\.ssh\actions_repo_1"
  ```
* Mac / Linux:

  ```
  ssh-keygen -t rsa -b 4096 -C "github-actions-sync-repo-b" -f ~/.ssh/actions_sync_key_repo_b
  ```

4. 终端会提示你输入密码 (Enter passphrase)。请直接按回车键。
5. 接着会提示你再次输入密码确认 (Enter same passphrase again)。请再次按回车键。

   重要提示： 如果你有多个目标仓库（例如 Repo-C），你需要为每一个目标仓库重复第 3-5 步，并为每个密钥文件使用不同的名称（例如 actions_sync_key_repo_c）。

**第二步：在“目标仓库”中配置部署密钥 (Deploy Key)**

你需要让每一个目标仓库信任我们为它生成的那个专属密钥，并给予写入权限。

1. 首先，获取为 Repo-B 生成的公钥内容。

* Windows (在 PowerShell 中运行):  

  ```
  Get-Content $env:USERPROFILE\.ssh\actions_repo_1.pub | Set-Clipboard
  ```
* Mac / Linux:

  ```
  cat ~/.ssh/actions_sync_key_repo_b.pub
  ```

2. 打开浏览器，进入你的目标仓库 Repo-B 的 GitHub 页面。
3. 进入 Settings > Security > Deploy keys。
4. 点击 Add deploy key，在 Key 字段中粘贴刚刚复制的公钥内容，并勾选 Allow write access。

   重要提示： 如果你有第二个目标仓库 Repo-C，你需要获取为 Repo-C 生成的那个独一无二的公钥（例如 actions_sync_key_repo_c.pub），并将其添加到 Repo-C 的 Deploy Keys 设置中。绝不要复用 Repo-B 的密钥。 

**第三步：在“主仓库”中配置秘密 (Secret)**

现在，你需要将所有生成的私钥安全地存放在主仓库 Repo-A 中。

1. 首先，获取为 Repo-B 生成的私钥内容。运行以下命令来查看并复制：

* Windows (在 PowerShell 中运行):

  ```
  Get-Content $env:USERPROFILE\.ssh\actions_repo_1 | Set-Clipboard
  ```
* Mac / Linux:

  ```
  cat ~/.ssh/actions_sync_key_repo_b
  ```

2. 将获取到的私钥内容添加到 Repo-A 的 Settings > Secrets and variables > Actions 中。  

* Secret 名称: REPO_B_SSH_PRIVATE_KEY
* Secret 内容: (粘贴你刚刚复制的私钥内容)\
  重要提示： 如果你有第二个目标仓库 Repo-C，你需要将为 Repo-C 生成的那个独一无二的私钥（例如 actions_sync_key_repo_c），添加为一个新的 Secret。请确保为它起一个唯一的名字，例如 REPO_C_SSH_PRIVATE_KEY。

**第四步：在“主仓库”中创建 Workflow 文件**
最后一步，我们需要在主仓库 Repo-A 中创建一个文件，告诉 GitHub Actions 具体要做什么。我们现在将使用一个自定义脚本来推送代码，以便在推送前移除工作流文件。

1. 在你的本地 Repo-A 仓库的根目录下，创建 .github/workflows/sync-repos.yml 文件。
2. 将下面的 YAML 代码复制并粘贴到 sync-repos.yml 文件中。  

   ```
   # 文件名: .github/workflows/sync-repos.yml
   name: Sync to Other Repositories

   on:
     push:
       branches:
         - main # 只在推送到 main 分支时触发

   jobs:
     sync:
       runs-on: ubuntu-latest
       steps:
         # 步骤一：签出（下载）主仓库的程式码
         - name: Checkout Main Repo
           uses: actions/checkout@v3
           with:
             fetch-depth: 0

         # 新增步骤：安装 git-filter-repo 工具
         - name: Install git-filter-repo
           run: pip3 install git-filter-repo

         # 步骤二：推送到你的第一个目标仓库 (Repo-B)，并排除工作流文件夹
         - name: Push to Target Repository (Repo-B)
           run: |
             # 设置 SSH 环境
             mkdir -p ~/.ssh
             echo "${{ secrets.REPO_B_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
             chmod 600 ~/.ssh/id_rsa
             ssh-keyscan github.com >> ~/.ssh/known_hosts

             # 克隆当前仓库到一个临时目录
             git clone . ../repo-clone-b
             cd ../repo-clone-b

             # 使用 git-filter-repo 工具移除 .github/workflows 文件夹
             git-filter-repo --path .github/workflows --invert-paths --force

             # 重新添加一个名为 origin 的远程地址，指向目标仓库 Repo-B
             git remote add origin git@github.com:YourUsername/repo-b.git

             # 以镜像模式推送处理后的代码到目标仓库
             git push --mirror origin

         # (可选) 步骤三：推送到你的第二个目标仓库 (Repo-C)，并排除工作流文件夹
         - name: Push to Second Target Repository (Repo-C)
           if: success() # 仅在前一步成功时执行
           run: |
             # 设置 SSH 环境
             mkdir -p ~/.ssh
             echo "${{ secrets.REPO_C_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
             chmod 600 ~/.ssh/id_rsa
             ssh-keyscan github.com >> ~/.ssh/known_hosts

             # 克隆当前仓库到一个临时目录
             # 注意：这里我们从原始的检出目录重新克隆
             cd $GITHUB_WORKSPACE 
             git clone . ../repo-clone-c
             cd ../repo-clone-c

             # 移除 .github/workflows 文件夹
             git-filter-repo --path .github/workflows --invert-paths --force

             # 重新添加一个名为 origin 的远程地址，指向目标仓库 Repo-C
             git remote add origin git@github.com:YourOtherUsername/repo-c.git

             # 以镜像模式推送处理后的代码到目标仓库
             git push --mirror origin
   ```
3. 修改关键信息：根据你自己的用户名和仓库名，修改 YAML 文件中每一处的 git@github.com:YourUsername/repo-b.git 等 URL 地址。
4. 保存文件，然后将这些新的文件提交并推送到你的主仓库 Repo-A。

**第五步：测试与验证**  

推送完成后，进入你的主仓库 Repo-A 的 Actions 标签页，检查工作流是否成功运行。如果成功，你的代码应该已经被同步到所有配置的目标仓库中了，并且目标仓库里不会包含 .github/workflows 文件夹。
